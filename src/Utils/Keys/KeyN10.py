


"""
    A class that simulates a key in string form that contains only arithmetic numerals (the range {0, 1, ..., 9}).
    The string may only contain those arithmetic numerals in the range {0, 1, ..., keyLen}.
    The string may not contain any duplicate characters.
    A key is generated from a seed. The seed is a value from {0, 1, ..., keyLen! - 1}, where
    seed 0 corresponds to key '01 ... 89' and seed (keyLen! - 1) corresponds to '98 ... 10'.
    It provides incrementation and decrementation of the key, such that the key after the
    incr (decr) operation is the key generated by seed+1 (seed-1), with seed being the seed that
    generates the key from before incr (decr) was executed.
"""
import copy
from math import factorial, floor


class KeyN10:
    def __init__(self, keyLen: int, seed: int):
        keyLen = max(0, min(keyLen, 10))        # clamp 0 <= keyLen <= 10
        seed %= factorial(keyLen)
        self.__symbols = [num for num in range(keyLen)]

        self.__key, self.__indices = self.__generateKey(seed, keyLen)

        self.__cache = None
        self.__cacheIsValid = False

    def __getitem__(self, index: int):
        index %= len(self.__key)
        return self.__key[index]

    def __len__(self):
        return len(self.__key)

    def __repr__(self):
        return self.key()

    """
        Acts as if index :i: of the seed has just been decremented. As the key may not contain any
        duplicate characters and contains only characters in the range {0, 1, ..., keyLen}, all characters
        from and including the specified index :i: cannot bet guaranteed to remain the same. Overflow of
        the incremented index may still alter characters at an index less than :i: through a carry value.
        :param i: The index to increment. Enforces i < len(key) - 1; the seed must be incremented by
                at least one. Indexation treats negative i values as indexing from the end to
                the front instead of front to end.
        Returns overflow boolean.
    """
    def incr(self, index: int = -1):
        self.__cacheIsValid = False

        # backtrack
        index %= self.__len__()
        backtrackList = self.__key[index:]
        prevBranch = self.__indices[index]
        prevMaxBranch = self.__len__() - index - 1

        while index > 0 and prevBranch == prevMaxBranch:
            index -= 1
            backtrackList.append(self.__key[index])

            prevBranch = self.__indices[index]
            prevMaxBranch += 1

        overflow = prevBranch == prevMaxBranch and len(backtrackList) == self.__len__()
        backtrackList.sort()

        branch = prevBranch + 1 if prevBranch < prevMaxBranch else 0
        self.__key[index] = backtrackList.pop(branch)
        self.__indices[index] = branch
        index += 1

        # rework
        for i in range(index, self.__len__()):
            self.__indices[i] = 0
            self.__key[i] = backtrackList.pop(0)


        return overflow

    """
        Acts as if index :i: of the seed has just been incremented. As the key may not contain any
        duplicate characters and contains only characters in the range {0, 1, ..., keyLen}, all characters
        from and including the specified index :i: cannot bet guaranteed to remain the same. Underflow of
        the decremented index may still alter characters at an index less than :i: through value borrowing.
        :param i: The index to decrement. Enforces i < len(key) - 1; the seed must be decremented by
                at least one. Indexation treats negative i values as indexing from the end to
                the front instead of front to end.
        Returns underflow boolean.
    """
    def decr(self, index: int = -1):
        self.__cacheIsValid = False

        # backtrack
        index %= self.__len__()
        backtrackList = self.__key[index:]
        prevBranch = self.__indices[index]
        MIN_BRANCH = 0   # constant

        while index > 0 and prevBranch == MIN_BRANCH:
            index -= 1
            backtrackList.append(self.__key[index])

            prevBranch = self.__indices[index]

        underflow = prevBranch == MIN_BRANCH and len(backtrackList) == self.__len__()
        backtrackList.sort()

        branch = prevBranch - 1 if prevBranch > MIN_BRANCH else len(backtrackList) - 1
        self.__key[index] = backtrackList.pop(branch)
        self.__indices[index] = branch
        index += 1

        # rework
        for i in range(index, self.__len__()):
            back = len(backtrackList) - 1
            self.__indices[i] = back
            self.__key[i] = backtrackList.pop(back)

        return underflow

    """
        Return the key in string form.
    """
    def key(self):
        self.__updateCache()
        return self.__cache

    """
        Return the key in list form.
    """
    def keyList(self):
        return self.__key

    """
        Return seed of the current key.
    """
    def seed(self):
        seed = 0
        nrChoices = self.__len__()

        for index in self.__indices:
            seed += index * factorial(nrChoices - 1)
            nrChoices -= 1

        return seed

    def __updateCache(self):
        if not self.__cacheIsValid:
            temp = [str(elem) for elem in self.__key]
            self.__cache = ''.join(temp)
            self.__cacheIsValid = True

    def __generateKey(self, seed: int, keyLen: int):
        key = []
        indices = []
        symbols = copy.deepcopy(self.__symbols)
        for nrChoices in range(keyLen, 0, -1):
            nrLeaves = factorial(nrChoices - 1)   # nr of leaves of any subtree on level keyLen - nrChoices (root==0)
            factor = seed / nrLeaves
            index = floor(factor)
            seed -= index * nrLeaves              # choosing subtree index (0 -> nrChoices) trims index*nrLeaves leaves

            res = symbols.pop(index)
            key.append(res)

            indices.append(index)

        return key, indices

