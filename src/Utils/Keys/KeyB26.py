
"""
    A class that simulates a key in string form that contains only lower case
    OR upper case latin letters, never a combination of both.
    A key is generated from a seed. The seed is a value from
    0 to (26^keyLen)-1, where seed 0 corresponds to key 'AA ... AA'
    and seed (26^keyLen)-1 corresponds to 'ZZ ... ZZ'. The least significant
    character is at index 0 of the key.
    It provides incrementation and decrementation of the key. These operations require you to specify
    an index i to increment or decrement, such that the key after the incr(i) (decr(i)) operation is
    the key generated by seed+(26^i) (seed-(26^i)), with seed being the seed that
    generates the key before incr (decr) is executed.
"""
from src.Utils.Utils import diffChars, sumChars


def toSeed(key: str):
    if not key.isalpha():
        raise ValueError("Cannot convert non-alpha key to KeyB26 seed")

    seed: int = 0
    for i, c in enumerate(key.upper()):
        seed += (ord(c) % 0x41) * pow(26, i)
    return seed


class KeyB26:
    def __init__(self, keyLen: int, seed: int, upper: bool = True):
        if keyLen < 1:
            raise ValueError(f"KeyB26 keyLen < 1: {keyLen}")

        self.isUpper = upper
        self.__key = self.__generateKey(seed, keyLen)
        self.__key = [c.upper() if upper else c.lower() for c in self.__key]

        self.__cache = ""
        self.__cacheIsValid = False

    def __getitem__(self, index: int):
        index %= len(self.__key)
        return self.__key[index]

    def __len__(self):
        return len(self.__key)

    def __repr__(self):
        return self.key()

    """
        Acts as if index i of the seed has just been incremented.
        :param i: The index to increment. The seed will be increased by 26^i. Indexation
                treats negative i values as indexing from the end to the front instead of front to end.
        Returns overflow boolean.
    """
    def incr(self, index: int = 0):
        self.__cacheIsValid = False
        key = self.__key
        index %= len(key)

        # Push carry value up
        while index < len(key) and key[index] == self.max():
            key[index] = sumChars(key[index], self.one())
            index += 1

        # Lend a value (final carry assignment)
        if index < len(key):
            key[index] = sumChars(key[index], self.one())

        return index == len(key)

    """
        Acts as if the seed has just been decremented.
        :param i: The index to decrement. The seed will be lowered by 26^i. Indexation
                treats negative i values as indexing from the end to the front instead of front to end.
        Returns underflow boolean.
    """
    def decr(self, i: int = 0):
        self.__cacheIsValid = False
        underflow: bool = False
        key = self.__key
        i %= len(key)
        index: int = i

        # find index to borrow from
        while index < len(key) and key[index] == self.zero():
            index += 1

        # handle underflow
        if index >= len(key):
            index -= 1
            underflow = True

        # redistribute borrowed value
        while index >= i:
            key[index] = diffChars(key[index], self.one())
            index -= 1

        return underflow

    """
        Return the key in string form.
    """
    def key(self):
        self.__updateCache()
        return self.__cache

    def isalpha(self):
        self.__updateCache()
        return self.__cache.isalpha()

    def iscapital(self):
        return self.isUpper

    """
        Return seed of the current key.
    """
    def seed(self):
        self.__updateCache()
        return toSeed(self.__cache)


    def one(self):
        return 'B'

    def max(self):
        return 'Z'

    def zero(self):
        return 'A'

    def __updateCache(self):
        if not self.__cacheIsValid:
            self.__cache = ''.join(self.__key)
            self.__cacheIsValid = True

    def __generateKey(self, seed: int, keyLen: int):
        key = ['A'] * keyLen
        seed %= pow(26, keyLen)
        for index in range(keyLen - 1, -1, -1):
            powVal = pow(26, index)
            charValue = seed // powVal
            seed %= powVal
            if charValue <= 25:
                key[index] = chr(charValue + 0x41)

        return key

